<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Game Viewer FPS</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        #game-container {
            width: 100%;
            height: 100%;
        }
        #virtual-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: none;
        }
        #joystick-knob {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            top: 30px;
            left: 30px;
        }
    </style>
</head>
<body>
    <div id="game-container"></div>
    <div id="virtual-joystick">
        <div id="joystick-knob"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        let scene, camera, renderer, controls, player;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let joystick = { active: false, vector: new THREE.Vector2() };
        let isGamepadConnected = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let cameraRotation = new THREE.Vector2(); 
        let gyroData = { alpha: 0, beta: 0, gamma: 0 };
        let smoothedGyroData = { alpha: 0, beta: 0, gamma: 0 };
        const smoothingFactor = 0.1;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x999999, side: THREE.DoubleSide });
            const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
            floorMesh.rotation.x = -Math.PI / 2;
            scene.add(floorMesh);

            // Add grid to help visualize movement
            const gridHelper = new THREE.GridHelper(1000, 100);
            scene.add(gridHelper);

            // Add some cubes for reference
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshPhongMaterial({ color: Math.random() * 0xffffff });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(
                    Math.random() * 100 - 50,
                    1,
                    Math.random() * 100 - 50
                );
                scene.add(cube);
            }

            // STL Model
            const loader = new THREE.STLLoader();
            loader.load('modelo.stl', (geometry) => {
                const material = new THREE.MeshPhongMaterial({ color: 0xffd700, specular: 0x111111, shininess: 200 });
                const model = new THREE.Mesh(geometry, material);
                
                geometry.computeBoundingBox();
                const center = new THREE.Vector3();
                geometry.boundingBox.getCenter(center);
                model.position.sub(center);
                
                const scale = 2 / geometry.boundingBox.getSize(new THREE.Vector3()).length();
                model.scale.set(scale, scale, scale);
                
                model.position.set(10, 1, 10); 
                
                scene.add(model);
            });

            // First-person controls
            controls = new THREE.PointerLockControls(camera, renderer.domElement);
            scene.add(controls.getObject());

            // Click to start controls
            document.getElementById('game-container').addEventListener('click', function() {
                controls.lock();
            });

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            window.addEventListener('gamepadconnected', handleGamepadConnected);
            window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);

            // Touch controls for camera movement
            let touchStartX, touchStartY;
            document.addEventListener('touchstart', onTouchStart);
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd); 

            setupVirtualJoystick();

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.016; 

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

            if (joystick.active) {
                velocity.x -= joystick.vector.x * 400.0 * delta;
                velocity.z -= joystick.vector.y * 400.0 * delta;
            }

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Apply camera rotation
            if (isGamepadConnected) {
                // VR-style rotation using smoothed gyroscope data
                const rotationX = THREE.MathUtils.degToRad(smoothedGyroData.beta);
                const rotationY = THREE.MathUtils.degToRad(-smoothedGyroData.alpha);
                const rotationZ = THREE.MathUtils.degToRad(smoothedGyroData.gamma);

                camera.quaternion.setFromEuler(new THREE.Euler(rotationX, rotationY, rotationZ, 'YXZ'));
            } else {
                // Touch-based rotation
                camera.rotation.y -= cameraRotation.x * 0.05;
                camera.rotation.x -= cameraRotation.y * 0.05;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }

            // Handle gamepad input
            updateGamepadState();

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        }

        function handleGamepadConnected() {
            isGamepadConnected = true;
            document.getElementById('virtual-joystick').style.display = 'none';
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleOrientation);
            }
        }

        function handleGamepadDisconnected() {
            isGamepadConnected = false;
            document.getElementById('virtual-joystick').style.display = 'block';
            window.removeEventListener('deviceorientation', handleOrientation);
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].pageX;
                touchStartY = event.touches[0].pageY;
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1) {
                const touchEndX = event.touches[0].pageX;
                const touchEndY = event.touches[0].pageY;
                const dx = touchEndX - touchStartX;
                const dy = touchEndY - touchStartY;

                cameraRotation.x = dx * 0.002;
                cameraRotation.y = dy * 0.002;

                touchStartX = touchEndX;
                touchStartY = touchEndY;
            }
        }

        function onTouchEnd() {
            cameraRotation.set(0, 0);
        }

        function updateGamepadState() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                const gamepad = gamepads[i];
                if (gamepad) {
                    const axesThreshold = 0.1;
                    moveForward = gamepad.axes[1] < -axesThreshold;
                    moveBackward = gamepad.axes[1] > axesThreshold;
                    moveLeft = gamepad.axes[0] < -axesThreshold;
                    moveRight = gamepad.axes[0] > axesThreshold;
                    return;
                }
            }
        }


        function setupVirtualJoystick() {
            const joystickElement = document.getElementById('virtual-joystick');
            const knob = document.getElementById('joystick-knob');
            let isDragging = false;

            joystickElement.addEventListener('touchstart', startDragging);
            joystickElement.addEventListener('touchmove', drag);
            joystickElement.addEventListener('touchend', stopDragging);

            joystickElement.addEventListener('mousedown', startDragging);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDragging);

            function startDragging(e) {
                isDragging = true;
                joystick.active = true;
                drag(e);
            }

            function stopDragging() {
                isDragging = false;
                joystick.active = false;
                joystick.vector.set(0, 0);
                knob.style.transform = 'translate(0px, 0px)';
            }

            function drag(e) {
                if (!isDragging) return;

                const joystickRect = joystickElement.getBoundingClientRect();
                const centerX = joystickRect.width / 2;
                const centerY = joystickRect.height / 2;

                let clientX, clientY;

                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const deltaX = clientX - joystickRect.left - centerX;
                const deltaY = clientY - joystickRect.top - centerY;

                const distance = Math.min(joystickRect.width / 2, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
                const angle = Math.atan2(deltaY, deltaX);

                const moveX = Math.cos(angle) * distance;
                const moveY = Math.sin(angle) * distance;

                knob.style.transform = `translate(${moveX}px, ${moveY}px)`;

                joystick.vector.set(moveX / (joystickRect.width / 2), moveY / (joystickRect.height / 2));
            }

            if (!isGamepadConnected) {
                joystickElement.style.display = 'block';
            }
        }

        function handleOrientation(event) {
            if (isGamepadConnected) {
                gyroData.alpha = event.alpha;
                gyroData.beta = event.beta;
                gyroData.gamma = event.gamma;

                smoothedGyroData.alpha += smoothingFactor * (gyroData.alpha - smoothedGyroData.alpha);
                smoothedGyroData.beta += smoothingFactor * (gyroData.beta - smoothedGyroData.beta);
                smoothedGyroData.gamma += smoothingFactor * (gyroData.gamma - smoothedGyroData.gamma);
            }
        }

        let prevTime = performance.now();
        init();
    </script>
</body>
</html>